/*=============================================================================

    This file is part of FLINT.

    FLINT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    FLINT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with FLINT; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA

=============================================================================*/
/******************************************************************************

    Copyright (C) 2012,2013 Andres Goens
    Copyright (C) 2012 Sebastian Pancratz

******************************************************************************/

*******************************************************************************

    Module documentation

    We represent a polynomial in $\mathbf{F}_q[X]$ as a \code{struct} 
    which includes an array \code{coeffs} with the coefficients, as
    well as the length \code{length} and the number \code{alloc} of 
    coefficients for which memory has been allocated.

    As a data structure, we call this polynomial \emph{normalised} 
    if the top coefficient is non-zero.

    Unless otherwise stated here, all functions that deal with polynomials 
    assume that the $\mathbf{F}_q$ context of said polynomials are compatible, 
    i.e., it assumes that the fields are generated by the same polynomial.

*******************************************************************************

*******************************************************************************

    Memory management

*******************************************************************************

fq_struct * _fq_poly_init(long len)

    Initializes a polynomial as an array of \code{fq_struct}, 
    of length \code{len}. Returns a pointer to the first coefficient.

void fq_poly_init(fq_poly_t poly)

    Initialises \code{poly} for use, with context ctx, and setting 
    its length to zero. A corresponding call to \code{fq_poly_clear()} 
    must be made after finishing with the \code{fq_poly_t} to free the memory 
    used by the polynomial.

void fq_poly_init2(fq_poly_t poly, long alloc)

    Initialises \code{poly} with space for at least \code{alloc} coefficients 
    and sets the length to zero.  The allocated coefficients are all set to 
    zero.  A corresponding call to \code{fq_poly_clear()} 
    must be made after finishing with the \code{fq_poly_t} to free the memory 
    used by the polynomial.

void fq_poly_realloc(fq_poly_t poly, long alloc)

    Reallocates the given polynomial to have space for \code{alloc} 
    coefficients.  If \code{alloc} is zero the polynomial is cleared 
    and then reinitialised.  If the current length is greater than 
    \code{alloc} the polynomial is first truncated to length \code{alloc}.

void fq_poly_fit_length(fq_poly_t poly, long len);

    If \code{len} is greater than the number of coefficients currently 
    allocated, then the polynomial is reallocated to have space for at 
    least \code{len} coefficients.  No data is lost when calling this 
    function.

    The function efficiently deals with the case where \code{fit_length} is 
    called many times in small increments by at least doubling the number 
    of allocated coefficients when length is larger than the number of 
    coefficients currently allocated.

void _fq_poly_set_length(fq_poly_t poly, long newlen)

    Sets the coefficients of \code{poly} beyond \code{len} to zero 
    and sets the length of \code{poly} to \code{len}.

void fq_poly_clear(fq_poly_t poly)

    Clears the given polynomial, releasing any memory used.  It must 
    be reinitialised in order to be used again.

void _fq_poly_normalise(fq_poly_t poly)

    Sets the length of \code{poly} so that the top coefficient is non-zero. 
    If all coefficients are zero, the length is set to zero.  This function 
    is mainly used internally, as all functions guarantee normalisation.

void _fq_poly_normalise2(fq_struct *poly, long *length)

    Sets the length \code{length} of \code{(poly,length)} so that the
    top coefficient is non-zero. If all coefficients are zero, the length 
    is set to zero. This function is mainly used internally, as all 
    functions guarantee normalisation.

void fq_poly_truncate(fq_poly_t poly, long newlen)

    Truncates the polynomial to length at most~$n$.

*******************************************************************************

    Polynomial parameters

*******************************************************************************

long fq_poly_degree(fq_poly_t poly)

    Returns the degree of the polynomial \code{poly}.

long fq_poly_length(fq_poly_t poly)

    Returns the length of the polynomial \code{poly}.

fq_struct * fq_poly_lead(const fq_poly_t poly)

    Returns a pointer to the leading coefficient of \code{poly}, 
    or \code{NULL} if \code{poly} is the zero polynomial.

*******************************************************************************

    Randomisation

*******************************************************************************

void fq_poly_randtest(fq_poly_t f, flint_rand_t state, 
                      long len, const fq_ctx_t ctx)

    Sets $f$ to a random polynomial of length at most \code{len} 
    with entries in the field described by \code{ctx}.

void fq_poly_randtest_not_zero(fq_poly_t f, flint_rand_t state, 
                               long len, const fq_ctx_t ctx)

    Same as \code{fq_poly_randtest} but guarantees that the polynomial
    is not zero.

*******************************************************************************

    Assignment and basic manipulation

*******************************************************************************

void _fq_poly_set(fq_struct *rop, const fq_struct *op, long len)

    Sets \code{(rop, len}) to \code{(op, len)}.

void fq_poly_set(fq_poly_t poly1, const fq_poly_t poly2)

    Sets the polynomial \code{poly1} to the polynomial \code{poly2}.

void fq_poly_set_fq(fq_poly_t poly, const fq_t c)

    Sets the polynomial \code{poly} to \code{c}.

void fq_poly_swap(fq_poly_t op1, fq_poly_t op2)

    Swaps the two polynomials \code{op1} and \code{op2}.

void _fq_poly_zero(fq_struct *rop, long len)

    Sets \code{(rop, len)} to the zero polynomial.

void fq_poly_zero(fq_poly_t poly)

    Sets \code{poly} to the zero polynomial.

void void fq_poly_one(fq_poly_t poly)

    Sets \code{poly} to the constant polynomial~$1$.


void fq_poly_make_monic(fq_poly_t rop, const fq_poly_t op, const fq_ctx_t ctx)

     Sets \code{rop} to \code{op}, normed to have leading coefficient 1.

void _fq_poly_make_monic(fq_struct *rop, const fq_struct *op, long length,
      const fq_ctx_t ctx);

     Sets \code{rop} to \code{(op,length)}, normed to have leading coefficient 1.
     Assumes that \code{rop} has enough space for the polynomial, assumes that
     \code{op} is not zero (and thus has an invertible leading coefficient). 

*******************************************************************************

    Getting and setting coefficients

*******************************************************************************

void fq_poly_get_coeff(fq_t x, const fq_poly_t poly, long n)

    Sets $x$ to the coefficient of $X^n$ in \code{poly}.

void fq_poly_set_coeff(fq_poly_t poly, long n, const fq_t x)

    Sets the coefficient of $X^n$ in \code{poly} to $x$.

*******************************************************************************

    Comparison

*******************************************************************************

int fq_poly_equal(const fq_poly_t poly1, const fq_poly_t poly2)

    Returns whether the two polynomials \code{poly1} and \code{poly2} 
    are equal.

int fq_poly_is_zero(const fq_poly_t poly)

    Returns whether the polynomial \code{poly} is the zero polynomial.

int fq_poly_is_one(const fq_poly_t op)

    Returns whether the polynomial \code{poly} is equal 
    to the constant polynomial~$1$.

int fq_poly_is_unit(const fq_poly_t op)

    Returns whether the polynomial \code{poly} is a unit in the polynomial
    ring $\mathbf{F}_q[X]$, i.e. if it has degree $0$ and is non-zero.

int fq_poly_equal_fq(const fq_poly_t poly, const fq_t c)

    Returns whether the polynomial \code{poly} is equal the (constant)
    $\mathbf{F}_q$ element \code{c}

*******************************************************************************

    Addition and subtraction

*******************************************************************************

void _fq_poly_add(fq_struct *res, 
                  const fq_struct *poly1, long len1, 
                  const fq_struct *poly2, long len2, 
                  const fq_ctx_t ctx)

    Sets \code{res} to the sum of \code{(poly1,len1)} and \code{(poly2,len2)}.

void fq_poly_add(fq_poly_t res, const fq_poly_t poly1, const fq_poly_t poly2, 
                 const fq_ctx_t ctx)

    Sets \code{res} to the sum of \code{poly1} and \code{poly2}.

void _fq_poly_sub(fq_struct *res, 
                  const fq_struct *poly1, long len1, 
                  const fq_struct *poly2, long len2, 
                  const fq_ctx_t ctx)

    Sets \code{res} to the difference of \code{(poly1,len1)} and \code{(poly2,len2)}.

void fq_poly_sub(fq_poly_t res, const fq_poly_t poly1, const fq_poly_t poly2, 
                 const fq_ctx_t ctx)

    Sets \code{res} to the difference of \code{poly1} and \code{poly2}.

void _fq_poly_neg(fq_struct *rop, const fq_struct *op, long len, 
                  const fq_ctx_t ctx)

    Sets \code{res} to the additive inverse of \code{(poly,len)}.

void fq_poly_neg(fq_poly_t res, const fq_poly_t poly, const fq_ctx_t ctx)

    Sets \code{res} to the additive inverse of \code{poly}.

*******************************************************************************

    Scalar multiplication and division

*******************************************************************************

void _fq_poly_scalar_mul_fq(fq_struct *rop, 
    const fq_struct *op, long len, const fq_t x, const fq_ctx_t ctx)

    Sets \code{(rop,len)} to the product of \code{(op,len)} by the
    scalar \code{x}, in the context defined by \code{ctx}. 

void fq_poly_scalar_mul_fq(fq_poly_t rop, 
    const fq_poly_t op, const fq_t x, const fq_ctx_t ctx)

    Sets \code{(rop,len)} to the product of \code{(op,len)} by the
    scalar \code{x}, in the context defined by \code{ctx}.

void _fq_poly_scalar_addmul_fq(fq_struct *rop, 
    const fq_struct *op, long len, const fq_t x, const fq_ctx_t ctx)

    Adds to \code{(rop,len)} the product of \code{(op,len)} by the
    scalar \code{x}, in the context defined by \code{ctx}.
    In particular, assumes the same length for \code{op} and 
    \code{rop}.
    
void fq_poly_scalar_addmul_fq(fq_poly_t rop, 
    const fq_poly_t op, const fq_t x, const fq_ctx_t ctx)

    Adds to \code{rop} the product of \code{op} by the
    scalar \code{x}, in the context defined by \code{ctx}.

void _fq_poly_scalar_submul_fq(fq_struct *rop, 
    const fq_struct *op, long len, const fq_t x, const fq_ctx_t ctx)

    Substracts from \code{(rop,len)} the product of \code{(op,len)} by the
    scalar \code{x}, in the context defined by \code{ctx}.
    In particular, assumes the same length for \code{op} and 
    \code{rop}.

void fq_poly_scalar_submul_fq(fq_poly_t rop, 
    const fq_poly_t op, const fq_t x, const fq_ctx_t ctx)

    Substracts from \code{rop} the product of \code{op} by the
    scalar \code{x}, in the context defined by \code{ctx}.

*******************************************************************************

    Multiplication

*******************************************************************************

void _fq_poly_mul_classical(fq_struct *rop, 
                            const fq_struct *op1, long len1, 
                            const fq_struct *op2, long len2, 
                            const fq_ctx_t ctx)

    Sets \code{(rop, len1 + len2 - 1)} to the product of \code{(op1, len1)} 
    and \code{(op2, len2)}, assuming that \code{len1} is at least \code{len2} 
    and neither is zero.

    Permits zero padding.  Does not support aliasing of \code{rop} 
    with either \code{op1} or \code{op2}.

void fq_poly_mul_classical(fq_poly_t rop, 
                           const fq_poly_t op1, const fq_poly_t op2, 
                           const fq_ctx_t ctx)

    Sets \code{rop} to the product of \code{op1} and \code{op2} 
    using classical polynomial multiplication.

void _fq_poly_mul_reorder(fq_struct *rop, 
                           const fq_struct *op1, long len1, 
                           const fq_struct *op2, long len2, 
                           const fq_ctx_t ctx)

    Sets \code{(rop, len1 + len2 - 1)} to the product of \code{(op1, len1)} 
    and \code{(op2, len2)}, assuming that \code{len1} and \code{len2} are 
    non-zero.

    Permits zero padding.  Supports aliasing.

void fq_poly_mul_reorder(fq_poly_t rop, 
    const fq_poly_t op1, const fq_poly_t op2, const fq_ctx_t ctx)

    Sets \code{rop} to the product of \code{op1} and \code{op2}, 
    reordering the two indeterminates $X$ and $Y$ when viewing 
    the polynomials as elements of $\mathbf{F}_p[X,Y]$.

    Suppose $\mathbf{F}_q = \mathbf{F}_p[X]/ (f(X))$ and recall 
    that elements of $\mathbf{F}_q$ are internally represented 
    by elements of type \code{fmpz_poly}.  For small degree extensions 
    but polynomials in $\mathbf{F}_q[Y]$ of large degree~$n$, we 
    change the representation to 
    \begin{equation*}
    \begin{split}
    g(Y) & = \sum_{i=0}^{n} a_i(X) Y^i \\
         & = \sum_{j=0}^{d} \sum_{i=0}^{n} \text{Coeff}(a_i(X), j) Y^i.
    \end{split}
    \end{equation*}
    This allows us to use a poor algorithm (such as classical multiplication) 
    in the $X$-direction and leverage the existing fast integer 
    multiplication routines in the $Y$-direction where the polynomial 
    degree~$n$ is large.

void _fq_poly_mul_KS(fq_struct *rop, const fq_struct *op1, long len1, 
                                     const fq_struct *op2, long len2, 
                                     const fq_ctx_t ctx)

    Sets \code{(rop, len1 + len2 - 1)} to the product of \code{(op1, len1)} 
    and \code{(op2, len2)}.

    Permits zero padding and places no assumptions on the 
    lengths \code{len1} and \code{len2}.  Supports aliasing.

void fq_poly_mul_KS(fq_poly_t rop, 
                    const fq_poly_t op1, const fq_poly_t op2, 
                    const fq_ctx_t ctx)

    Sets \code{rop} to the product of \code{op1} and \code{op2} 
    using Kronecker substitution, that is, by encoding each 
    coefficient in $\mathbf{F}_{q}$ as an integer and reducing 
    this problem to multiplying two polynomials over the integers.

void _fq_poly_mul(fq_struct *rop, 
                  const fq_struct *op1, long len1, 
                  const fq_struct *op2, long len2, const fq_ctx_t ctx)

    Sets \code{(rop, len1 + len2 - 1)} to the product of \code{(op1, len1)} 
    and \code{(op2, len2)}, choosing an appropriate algorithm.

    Permits zero padding.  Does not support aliasing.

void fq_poly_mul(fq_poly_t rop, 
    const fq_poly_t op1, const fq_poly_t op2, const fq_ctx_t ctx)

    Sets \code{rop} to the product of \code{op1} and \code{op2}, 
    choosing an appropriate algorithm.

void _fq_poly_mullow_classical(fq_struct *rop, 
                               const fq_struct *op1, long len1, 
                               const fq_struct *op2, long len2, long n, 
                               const fq_ctx_t ctx)

    Sets \code{(res, n)} to the first $n$ coefficients of \code{(poly1, len1)} 
    multiplied by \code{(poly2, len2)}.

    Assumes \code{0 < n <= len1 + len2 - 1}.  Assumes neither \code{len1} nor 
    \code{len2} is zero.

void fq_poly_mullow_classical(fq_poly_t rop, 
    const fq_poly_t op1, const fq_poly_t op2, long n, const fq_ctx_t ctx)

    Sets \code{res} to the product of \code{poly1} and \code{poly2}, computed 
    using the classical or schoolbook method.

void _fq_poly_mullow_KS(fq_struct *rop, 
                        const fq_struct *op1, long len1, 
                        const fq_struct *op2, long len2, long n, 
                        const fq_ctx_t ctx)

    Sets \code{(res, n)} to the lowest $n$ coefficients of the product of 
    \code{(poly1, len1)} and \code{(poly2, len2)}.

    Assumes that \code{len1} and \code{len2} are positive, but does allow 
    for the polynomials to be zero-padded.  The polynomials may be zero, 
    too.  Assumes $n$ is positive.  Supports aliasing between \code{res}, 
    \code{poly1} and \code{poly2}.

void fq_poly_mullow_KS(fq_poly_t rop, 
                       const fq_poly_t op1, const fq_poly_t op2, long n, 
                       const fq_ctx_t ctx)

    Sets \code{res} to the product of \code{poly1} and \code{poly2}.

void _fq_poly_mullow(fq_struct *rop, 
                     const fq_struct *op1, long len1, 
                     const fq_struct *op2, long len2, long n, 
                     const fq_ctx_t ctx)

    Sets \code{(res, n)} to the lowest $n$ coefficients of the product of 
    \code{(poly1, len1)} and \code{(poly2, len2)}.

    Assumes \code{0 < n <= len1 + len2 - 1}.  Allows for zero-padding in 
    the inputs.  Does not support aliasing between the inputs and the output.

void fq_poly_mullow(fq_poly_t rop, 
                    const fq_poly_t op1, const fq_poly_t op2, long n, 
                    const fq_ctx_t ctx)

    Sets \code{res} to the lowest $n$ coefficients of the product of 
    \code{poly1} and \code{poly2}.

*******************************************************************************

    Squaring

*******************************************************************************

void _fq_poly_sqr_classical(fq_struct *rop, 
                            const fq_struct *op, long len, 
                            const fq_ctx_t ctx)

    Sets \code{(rop, 2*len - 1)} to the square of \code{(op, len)}, 
    assuming that \code{(op,len)} is not zero and using classical
     polynomial multiplication.

    Permits zero padding.  Does not support aliasing of \code{rop} 
    with either \code{op1} or \code{op2}.

void fq_poly_sqr_classical(fq_poly_t rop, 
                           const fq_poly_t op, const fq_ctx_t ctx)

    Sets \code{rop} to the square of \code{op} using classical
     polynomial multiplication.
		       

void _fq_poly_sqr_reorder(fq_struct *rop, 
                          const fq_struct *op, long len, const fq_ctx_t ctx)

    Sets \code{(rop, 2*len- 1)} to the square of \code{(op, len)},
    assuming that \code{len} is not zero reordering the two indeterminates
    $X$ and $Y$ when viewing the polynomials as elements of $\mathbb{F}_p[X,Y]$.

    Permits zero padding.  Supports aliasing.

void fq_poly_sqr_reorder(fq_poly_t rop, 
                         const fq_poly_t op, const fq_ctx_t ctx)

    Sets \code{rop} to the square of \code{op},
    assuming that \code{len} is not zero reordering the two indeterminates
    $X$ and $Y$ when viewing the polynomials as elements of $\mathbb{F}_p[X,Y]$.
    See \code{fq_poly_mul_reorder}.


void _fq_poly_sqr_KS(fq_struct *rop, const fq_struct *op, long len, 
                                     const fq_ctx_t ctx)
    Sets \code{(rop, 2*len - 1)} to the square of \code{(op, len)}.

    Permits zero padding and places no assumptions on the 
    lengths \code{len1} and \code{len2}.  Supports aliasing.

void fq_poly_sqr_KS(fq_poly_t rop, const fq_poly_t op, const fq_ctx_t ctx)

    Sets \code{rop} to the square \code{op} using Kronecker substitution,
    that is, by encoding each coefficient in $\mathbf{F}_{q}$ as an integer
    and reducing this problem to multiplying two polynomials over the integers.

void _fq_poly_sqr(fq_struct *rop, const fq_struct *op, long len, 
                                  const fq_ctx_t ctx)

    Sets \code{(rop, 2* len - 1)} to the square of \code{(op, len)}, 
    choosing an appropriate algorithm.

    Permits zero padding.  Does not support aliasing.

void fq_poly_sqr(fq_poly_t rop, const fq_poly_t op, const fq_ctx_t ctx)

    Sets \code{rop} to the square of \code{op}, 
    choosing an appropriate algorithm.


*******************************************************************************

    Powering

*******************************************************************************

void _fq_poly_pow(fq_struct *rop, const fq_struct *op, long len, ulong e, 
                                  const fq_ctx_t ctx)

    Sets \code{res = poly^e}, assuming that \code{e, len > 0} and that 
    \code{res} has space for \code{e*(len - 1) + 1} coefficients.  Does 
    not support aliasing.

void fq_poly_pow(fq_poly_t rop, const fq_poly_t op, ulong e, 
                 const fq_ctx_t ctx)

    Computes \code{res = poly^e}.  If $e$ is zero, returns one, 
    so that in particular \code{0^0 = 1}.

*******************************************************************************

    Shifting

*******************************************************************************

void _fq_poly_shift_left(fq_struct *rop, 
                         const fq_struct *op, long len, long n)

    Sets \code{(res, len + n)} to \code{(poly, len)} shifted left by 
    $n$ coefficients.  

    Inserts zero coefficients at the lower end.  Assumes that \code{len} 
    and $n$ are positive, and that \code{res} fits \code{len + n} elements.
    Supports aliasing between \code{res} and \code{poly}.

void fq_poly_shift_left(fq_poly_t rop, const fq_poly_t op, long n)

    Sets \code{res} to \code{poly} shifted left by $n$ coeffs.  Zero 
    coefficients are inserted.

void _fq_poly_shift_right(fq_struct *rop, 
                          const fq_struct *op, long len, long n)

    Sets \code{(res, len - n)} to \code{(poly, len)} shifted right by 
    $n$ coefficients.  

    Assumes that \code{len} and $n$ are positive, that \code{len > n}, 
    and that \code{res} fits \code{len - n} elements.  Supports aliasing 
    between \code{res} and \code{poly}, although in this case the top 
    coefficients of \code{poly} are not set to zero.

void fq_poly_shift_right(fq_poly_t rop, const fq_poly_t op, long n)

    Sets \code{res} to \code{poly} shifted right by $n$ coefficients.  If $n$ 
    is equal to or greater than the current length of \code{poly}, \code{res} 
    is set to the zero polynomial.

*******************************************************************************

    Norms

*******************************************************************************

long _fq_poly_hamming_weight(const fq_poly *op, long len)

    Returns the number of non-zero entries in \code{(op, len)}.

long fq_poly_hamming_weight(const fq_poly_t op)

    Returns the number of non-zero entries in the polynomial \code{op}.

*******************************************************************************

    Euclidean division

*******************************************************************************

void _fq_poly_divrem_basecase(fq_struct *Q, fq_struct *R, 
    const fq_struct *A, long lenA, const fq_struct *B, long lenB, 
    const fq_t invB, const fq_ctx_t ctx)

    Computes \code{(Q, lenA - lenB + 1)}, \code{(R, lenA)} such that 
    $A = B Q + R$ with $0 \leq \len(R) < \len(B)$.

    Assumes that the leading coefficient of $B$ is invertible 
    and that \code{invB} is its inverse.

    Assumes that $\len(A), \len(B) > 0$.  Allows zero-padding in 
    \code{(A, lenA)}.  $R$ and $A$ may be aliased, but apart from 
    this no aliasing of input and output operands is allowed.

void fq_poly_divrem_basecase(fq_poly_t Q, fq_poly_t R, 
                             const fq_poly_t A, const fq_poly_t B, 
                             const fq_ctx_t ctx)

    Computes $Q$, $R$ such that $A = B Q + R$ with 
    $0 \leq \len(R) < \len(B)$.

    Assumes that the leading coefficient of $B$ is invertible.  This can 
    be taken for granted the context is for a finite field, that is, when 
    $p$ is prime and $f(X)$ is irreducible.

void _fq_poly_divrem(fq_struct *Q, fq_struct *R, 
    const fq_struct *A, long lenA, const fq_struct *B, long lenB, 
    const fq_t invB, const fq_ctx_t ctx)

    Computes \code{(Q, lenA - lenB + 1)}, \code{(R, lenA)} such that 
    $A = B Q + R$ with $0 \leq \len(R) < \len(B)$.

    Assumes that the leading coefficient of $B$ is invertible 
    and that \code{invB} is its inverse.

    Assumes that $\len(A), \len(B) > 0$.  Allows zero-padding in 
    \code{(A, lenA)}.  $R$ and $A$ may be aliased, but apart from 
    this no aliasing of input and output operands is allowed.

void fq_poly_divrem(fq_poly_t Q, fq_poly_t R, 
                    const fq_poly_t A, const fq_poly_t B, 
                    const fq_ctx_t ctx)

    Computes $Q$, $R$ such that $A = B Q + R$ with 
    $0 \leq \len(R) < \len(B)$.

    Assumes that the leading coefficient of $B$ is invertible.  This can 
    be taken for granted the context is for a finite field, that is, when 
    $p$ is prime and $f(X)$ is irreducible.

void _fq_poly_rem(fq_struct *R, const fq_struct *A, long lenA,
                  const fq_struct *B, long lenB, const fq_t invB,
                  const fq_ctx_t ctx)

    Sets \code{R} to the remainder of the division of \code{(A,lenA)} by
    \code{(B,lenB)}. Assumes that the leading coefficient of \code{(B,lenB)}
    is invertible and that \code{invB} is its inverse.

void fq_poly_rem(fq_poly_t R, 
                    const fq_poly_t A, const fq_poly_t B, 
                    const fq_ctx_t ctx)

    Sets \code{R} to the remainder of the division of \code{A} by
    \code{B} in the context described by \code{ctx}.

*******************************************************************************

    Greatest common divisor

*******************************************************************************



void fq_poly_gcd_euclidean(fq_poly_t rop, const fq_poly_t op1, const fq_poly_t op2, 
                                     const fq_ctx_t ctx)

    Sets \code{rop} to the greatest common divisor of \code{op1} and \code{op2}, 
    using the euclidean algorithm. The GCD of zero polynomials is
    defined to be zero, whereas the GCD of the zero polynomial and some other
    polynomial $P$ is defined to be $P$. Except in the case where
    the GCD is zero, the GCD $G$ is made monic. 

long _fq_poly_gcd_euclidean(fq_struct* G,const fq_struct* A, long lenA, 
                            const fq_struct* B, long lenB, const fq_ctx_t ctx);

    Computes the GCD of $A$ of length \code{lenA} and $B$ of length
    \code{lenB}, where \code{lenA >= lenB > 0} and sets $G$ to it. The length of
    the GCD $G$ is returned by the function. No attempt is made to make the GCD 
    monic. It is required that $G$ have space for \code{lenB} coefficients.

void fq_poly_gcd(fq_poly_t rop, const fq_poly_t op1, const fq_poly_t op2, 
                 const fq_ctx_t ctx)

    Sets \code{rop} to the greatest common divisor of \code{op1} and \code{op2}, 
    using the euclidean algorithm at the moment. The GCD of zero polynomials is
    defined to be zero, whereas the GCD of the zero polynomial and some other
    polynomial $P$ is defined to be $P$. Except in the case where
    the GCD is zero, the GCD $G$ is made monic. 

*******************************************************************************

    Divisibility testing

*******************************************************************************

int _fq_poly_divides(fq_struct *Q, 
                     const fq_struct *A, long lenA, 
                     const fq_struct *B, long lenB, const fq_t invB, 
                     const fq_ctx_t ctx)

    Returns $1$ if \code{(B, lenB)} divides \code{(A, lenA)} exactly and
    sets $Q$ to the quotient, otherwise returns $0$.

    It is assumed that $\len(A) \geq \len(B) > 0$ and that $Q$ has space
    for $\len(A) - \len(B) + 1$ coefficients.

    Aliasing of $Q$ with either of the inputs is not permitted.

    This function is currently unoptimised and provided for convenience
    only.

int fq_poly_divides(fq_poly_t Q, const fq_poly_t A, const fq_poly_t B, 
                                 const fq_ctx_t ctx)


    Returns $1$ if $B$ divides $A$ exactly and sets $Q$ to the quotient,
    otherwise returns $0$.

    This function is currently unoptimised and provided for convenience
    only.

*******************************************************************************

    Derivative

*******************************************************************************

void _fq_poly_derivative(fq_struct *rop, const fq_struct *op, long len, 
                                         const fq_ctx_t ctx)

    Sets \code{(rpoly, len - 1)} to the derivative of \code{(poly, len)}.  
    Also handles the cases where \code{len} is $0$ or $1$ correctly. 
    Supports aliasing of \code{rpoly} and \code{poly}.

void fq_poly_derivative(fq_poly_t rop, const fq_poly_t op, const fq_ctx_t ctx)

    Sets \code{res} to the derivative of \code{poly}.

*******************************************************************************

    Evaluation

*******************************************************************************

void _fq_poly_evaluate_fq(fq_t rop, const fq_struct *op, long len, 
                                    const fq_t a, const fq_ctx_t ctx)

    Sets \code{rop} to \code{(op, len)} evaluated at $a$.

    Supports zero padding.  There are no restrictions on \code{len}, that 
    is, \code{len} is allowed to be zero, too.

void fq_poly_evaluate_fq(fq_t rop, const fq_poly_t f, const fq_t a, 
                         const fq_ctx_t ctx)

    Sets \code{rop} to the value of $f(a)$.

    As the coefficient ring $\mathbf{F}_q$ is finite, Horner's method 
    is sufficient.

*******************************************************************************

    Composition

*******************************************************************************

void _fq_poly_compose_divconquer(fq_struct *rop, 
                                 const fq_struct *op1, long len1, 
                                 const fq_struct *op2, long len2, 
                                 const fq_ctx_t ctx)

    Computes the composition of \code{(op1, len1)} and \code{(op2, len2)} 
    using a divide and conquer approach and places the result into \code{rop}, 
    assuming \code{rop} can hold the output of length 
    \code{(len1 - 1) * (len2 - 1) + 1}.

    Assumes \code{len1, len2 > 0}.  Does not support aliasing between 
    \code{rop} and any of \code{(op1, len1)} and \code{(op2, len2)}.

void fq_poly_compose_divconquer(fq_poly_t rop, 
                                const fq_poly_t op1, const fq_poly_t op2, 
                                const fq_ctx_t ctx)

    Sets \code{rop} to the composition of \code{op1} and \code{op2}.  
    To be precise about the order of composition, denoting \code{rop}, 
    \code{op1}, and \code{op2} by $f$, $g$, and $h$, respectively, 
    sets $f(t) = g(h(t))$.

void _fq_poly_compose_horner(fq_struct *rop, const fq_struct *op1, long len1, 
                                             const fq_struct *op2, long len2, 
                                             const fq_ctx_t ctx)

    Sets \code{rop} to the composition of \code{(op1, len1)} and 
    \code{(op2, len2)}.

    Assumes that \code{rop} has space for \code{(len1-1)*(len2-1) + 1} 
    coefficients.  Assumes that \code{op1} and \code{op2} are non-zero 
    polynomials.  Does not support aliasing between any of the inputs and 
    the output.

void fq_poly_compose_horner(fq_poly_t rop, 
                            const fq_poly_t op1, const fq_poly_t op2, 
                            const fq_ctx_t ctx)

    Sets \code{rop} to the composition of \code{op1} and \code{op2}.  
    To be more precise, denoting \code{rop}, \code{op1}, and \code{op2} 
    by $f$, $g$, and $h$, sets $f(t) = g(h(t))$.

    This implementation uses Horner's method.

void _fq_poly_compose(fq_struct *rop, const fq_struct *op1, long len1, 
                                      const fq_struct *op2, long len2, 
                                      const fq_ctx_t ctx)

    Sets \code{rop} to the composition of \code{(op1, len1)} and 
    \code{(op2, len2)}.

    Assumes that \code{rop} has space for \code{(len1-1)*(len2-1) + 1} 
    coefficients.  Assumes that \code{op1} and \code{op2} are non-zero 
    polynomials.  Does not support aliasing between any of the inputs and 
    the output.

void fq_poly_compose(fq_poly_t rop, const fq_poly_t op1, const fq_poly_t op2, 
                     const fq_ctx_t ctx)

    Sets \code{rop} to the composition of \code{op1} and \code{op2}.  
    To be precise about the order of composition, denoting \code{rop}, 
    \code{op1}, and \code{op2} by $f$, $g$, and $h$, respectively, 
    sets $f(t) = g(h(t))$.

*******************************************************************************

    Output

*******************************************************************************

int _fq_poly_fprint_pretty(FILE *file, const fq_struct *poly, long len, 
                            const char *x, const fq_ctx_t ctx)

    Prints the pretty representation of \code{(poly, len)} to the stream 
    \code{file}, using the string \code{x} to represent the indeterminate.

    In case of success, returns a positive value.  In case of failure, 
    returns a non-positive value.

int fq_poly_fprint_pretty(FILE * file, const fq_poly_t poly, const char *x, 
                          const fq_ctx_t ctx)

    Prints the pretty representation of \code{poly} to the stream 
    \code{file}, using the string \code{x} to represent the indeterminate.

    In case of success, returns a positive value.  In case of failure, 
    returns a non-positive value.


int _fq_poly_print_pretty(const fq_struct *poly, long len, 
                          const char *x, const fq_ctx_t ctx)
    Prints the pretty representation of \code{(poly, len)} to \code{stdout},
    using the string \code{x} to represent the indeterminate.

    In case of success, returns a positive value.  In case of failure, 
    returns a non-positive value.


int fq_poly_print_pretty(const fq_poly_t poly, const char *x, 
                         const fq_ctx_t ctx)

    Prints the pretty representation of \code{poly} to \code{stdout},
    using the string \code{x} to represent the indeterminate.

    In case of success, returns a positive value.  In case of failure, 
    returns a non-positive value.
